<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Control Overlay - TikTok Stream Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #weather-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Debug overlay */
        #debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            display: none;
            z-index: 10000;
            max-width: 350px;
            border: 2px solid rgba(0, 255, 0, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }

        #debug-info.active {
            display: block;
        }

        #debug-info .status {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        #debug-info .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        #debug-info .status-dot.connected {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        #debug-info .status-dot.disconnected {
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Lightning flash overlay */
        #lightning-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 9998;
        }

        /* Connection status indicator */
        #connection-status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
            display: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #connection-status.show {
            display: block;
            opacity: 1;
        }

        #connection-status.connected {
            background: rgba(0, 128, 0, 0.8);
        }

        #connection-status.disconnected {
            background: rgba(255, 0, 0, 0.8);
        }

        #connection-status.reconnecting {
            background: rgba(255, 165, 0, 0.8);
        }
    </style>
</head>
<body>
    <div id="weather-container">
        <canvas id="weather-canvas"></canvas>
    </div>
    <div id="lightning-flash"></div>
    <div id="debug-info"></div>
    <div id="connection-status"></div>

    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>
    <!-- GSAP for smooth animations (served from local node_modules) -->
    <script src="/gsap/gsap.min.js"></script>

    <!-- Weather Engine -->
    <script>
        /**
         * Weather Control Engine - Modernized
         * 
         * GPU-accelerated weather effects with GSAP animations
         * Supports: rain, snow, storm, fog, thunder, sunbeam, glitchclouds
         */

        // Check if GSAP is loaded
        if (typeof gsap === 'undefined') {
            console.error('‚ùå GSAP library failed to load! Animations will not work.');
            console.error('Please ensure /gsap/gsap.min.js is accessible.');
            // Show error message on screen using safe DOM manipulation
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(255,0,0,0.9);color:white;padding:20px;border-radius:10px;font-family:monospace;text-align:center;z-index:99999;';
            const title = document.createElement('strong');
            title.textContent = '‚ö†Ô∏è GSAP Loading Error';
            errorDiv.appendChild(title);
            errorDiv.appendChild(document.createElement('br'));
            const msg1 = document.createTextNode('The GSAP animation library failed to load.');
            errorDiv.appendChild(msg1);
            errorDiv.appendChild(document.createElement('br'));
            const msg2 = document.createTextNode('Weather effects will not display.');
            errorDiv.appendChild(msg2);
            document.body.appendChild(errorDiv);
        }

        // Configuration
        const config = {
            debug: new URLSearchParams(window.location.search).get('debug') === 'true',
            maxParticles: 500,
            fpsCap: 60,
            showConnectionStatus: true,
            reconnectDelay: 1000,
            reconnectMaxDelay: 30000,
            reconnectBackoffMultiplier: 1.5
        };

        // DOM elements
        const canvas = document.getElementById('weather-canvas');
        const ctx = canvas.getContext('2d', { 
            alpha: true,
            desynchronized: true,  // Better performance
            willReadFrequently: false
        });
        const debugInfo = document.getElementById('debug-info');
        const lightningFlash = document.getElementById('lightning-flash');
        const connectionStatus = document.getElementById('connection-status');

        // Safe GSAP wrapper - fallback to setTimeout if GSAP not available
        const safeGsap = (() => {
            // Helper function to apply properties to target
            // GSAP-specific properties to exclude from direct assignment (GSAP 3.x)
            const gsapProps = ['duration', 'delay', 'ease', 'onComplete', 'repeat', 'yoyo', 'stagger', 'yoyoEase', 'onStart', 'onUpdate', 'onRepeat', 'repeatDelay'];
            
            function applyProperties(target, vars) {
                Object.keys(vars).forEach(key => {
                    if (!gsapProps.includes(key)) {
                        if (typeof target === 'object' && target !== null) {
                            try {
                                // Check if target is a DOM element with a style property
                                if (target.style && typeof target.style === 'object') {
                                    // Apply CSS properties via style
                                    target.style[key] = vars[key];
                                } else {
                                    // Apply directly to object (for plain objects)
                                    target[key] = vars[key];
                                }
                            } catch (error) {
                                // Silently ignore invalid property assignments
                                console.debug(`Could not apply property ${key} to target:`, error);
                            }
                        }
                    }
                });
            }
            
            return {
                to: (target, vars) => {
                    if (typeof gsap !== 'undefined') {
                        return gsap.to(target, vars);
                    } else {
                        // Fallback: apply properties directly without animation
                        // In the fallback, we skip the "animation" so we apply immediately
                        // The delay represents when the animation would start, so we delay the property application
                        const applyDelay = (vars.delay || 0) * 1000;
                        
                        setTimeout(() => {
                            applyProperties(target, vars);
                            
                            // Call onComplete after duration (since animation is instant in fallback)
                            if (vars.onComplete) {
                                const completionDelay = (vars.duration || 0) * 1000;
                                setTimeout(vars.onComplete, completionDelay);
                            }
                        }, applyDelay);
                        
                        return { kill: () => {} };
                    }
                },
                set: (target, vars) => {
                    if (typeof gsap !== 'undefined') {
                        return gsap.set(target, vars);
                    } else {
                        // Fallback: apply properties directly
                        applyProperties(target, vars);
                        return { kill: () => {} };
                    }
                }
            };
        })();

        // Responsive canvas sizing with device pixel ratio support
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            ctx.scale(dpr, dpr);
            
            log(`Canvas resized: ${displayWidth}x${displayHeight} (DPR: ${dpr})`);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // State management
        const state = {
            activeEffects: [],
            particles: [],
            socket: null,
            connected: false,
            reconnectAttempts: 0,
            animationId: null,
            lastFrameTime: 0,
            fps: 0,
            fpsHistory: [],
            totalEventsReceived: 0
        };

        // Particle class with optimized rendering
        class Particle {
            constructor(type, config = {}) {
                this.type = type;
                this.active = true;
                this.reset(config);
            }

            reset(config = {}) {
                const w = window.innerWidth;
                const h = window.innerHeight;
                
                this.x = config.x !== undefined ? config.x : Math.random() * w;
                this.y = config.startFromTop ? -20 : (config.y !== undefined ? config.y : Math.random() * h);
                this.z = Math.random(); // Depth for parallax (0-1)
                this.active = true;
                
                switch (this.type) {
                    case 'rain':
                        this.speedY = 15 + Math.random() * 15;
                        this.speedX = Math.random() * 3 - 1.5;
                        this.length = 15 + Math.random() * 25;
                        this.width = 1 + Math.random() * 1.5;
                        this.alpha = 0.4 + Math.random() * 0.4;
                        this.color = `rgba(160, 196, 232, ${this.alpha})`;
                        break;
                    
                    case 'snow':
                        this.speedY = 1 + Math.random() * 2.5;
                        this.speedX = Math.random() * 2 - 1;
                        this.size = 2 + Math.random() * 5;
                        this.alpha = 0.5 + Math.random() * 0.5;
                        this.wobble = Math.random() * Math.PI * 2;
                        this.wobbleSpeed = 0.02 + Math.random() * 0.04;
                        this.rotation = Math.random() * Math.PI * 2;
                        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                        break;
                    
                    case 'storm':
                        this.speedY = 20 + Math.random() * 20;
                        this.speedX = 8 + Math.random() * 12;
                        this.length = 20 + Math.random() * 35;
                        this.width = 1.5 + Math.random() * 2;
                        this.alpha = 0.5 + Math.random() * 0.4;
                        this.color = `rgba(107, 163, 214, ${this.alpha})`;
                        break;
                    
                    case 'fog':
                        this.speedY = 0.3 + Math.random() * 0.4;
                        this.speedX = 0.5 + Math.random() - 0.5;
                        this.size = 80 + Math.random() * 200;
                        this.alpha = 0.15 + Math.random() * 0.2;
                        this.life = 0;
                        this.maxLife = 250 + Math.random() * 400;
                        this.hue = 200 + Math.random() * 20; // Slight color variation
                        break;
                }
            }

            update(deltaTime, intensity = 1.0) {
                const speed = deltaTime / 16.67; // Normalize to 60fps
                const w = window.innerWidth;
                const h = window.innerHeight;
                
                switch (this.type) {
                    case 'rain':
                        this.y += this.speedY * speed * intensity;
                        this.x += this.speedX * speed;
                        if (this.y > h + 20) {
                            this.reset({ startFromTop: true });
                        }
                        if (this.x < -20 || this.x > w + 20) {
                            this.x = Math.random() * w;
                        }
                        break;
                    
                    case 'snow':
                        this.y += this.speedY * speed * intensity;
                        this.wobble += this.wobbleSpeed * speed;
                        this.x += Math.sin(this.wobble) * 0.8 * speed + this.speedX * speed;
                        this.rotation += this.rotationSpeed * speed;
                        if (this.y > h + 20) {
                            this.reset({ startFromTop: true });
                        }
                        if (this.x < -20) this.x = w + 20;
                        if (this.x > w + 20) this.x = -20;
                        break;
                    
                    case 'storm':
                        this.y += this.speedY * speed * intensity;
                        this.x += this.speedX * speed * intensity;
                        if (this.y > h + 50) {
                            this.reset({ startFromTop: true });
                        }
                        if (this.x > w + 100) {
                            this.x = -100;
                            this.y = Math.random() * h;
                        }
                        break;
                    
                    case 'fog':
                        this.y += this.speedY * speed;
                        this.x += this.speedX * speed;
                        this.life += speed;
                        // Smooth fade in/out using sine wave
                        const lifePercent = this.life / this.maxLife;
                        this.alpha = Math.sin(lifePercent * Math.PI) * 0.25;
                        if (this.life > this.maxLife) {
                            this.reset();
                        }
                        if (this.x < -this.size) this.x = w + this.size;
                        if (this.x > w + this.size) this.x = -this.size;
                        break;
                }
            }

            draw() {
                if (!this.active) return;
                
                ctx.save();
                ctx.globalAlpha = this.alpha;
                
                switch (this.type) {
                    case 'rain':
                    case 'storm':
                        ctx.strokeStyle = this.color || (this.type === 'storm' ? '#6ba3d6' : '#a0c4e8');
                        ctx.lineWidth = this.width;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.x - this.speedX * 2, this.y - this.length);
                        ctx.stroke();
                        break;
                    
                    case 'snow':
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.rotation);
                        
                        // Draw snowflake with multiple points
                        const points = 6;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        for (let i = 0; i < points; i++) {
                            const angle = (i * Math.PI * 2) / points;
                            const x = Math.cos(angle) * this.size;
                            const y = Math.sin(angle) * this.size;
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        // Add sparkle effect occasionally
                        if (Math.random() > 0.96) {
                            ctx.fillStyle = '#ffffdd';
                            ctx.globalAlpha = 0.9;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.size * 0.4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.restore();
                        break;
                    
                    case 'fog':
                        const gradient = ctx.createRadialGradient(
                            this.x, this.y, 0,
                            this.x, this.y, this.size
                        );
                        const color = `hsl(${this.hue}, 15%, 75%)`;
                        gradient.addColorStop(0, `hsla(${this.hue}, 15%, 75%, ${this.alpha})`);
                        gradient.addColorStop(0.5, `hsla(${this.hue}, 15%, 70%, ${this.alpha * 0.5})`);
                        gradient.addColorStop(1, 'rgba(180, 180, 200, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                
                ctx.restore();
            }

            destroy() {
                this.active = false;
            }
        }

        // Effect handlers with GSAP animations
        const effects = {
            rain: {
                start(intensity = 0.5, duration = 10000) {
                    const particleCount = Math.floor(250 * intensity);
                    const newParticles = [];
                    
                    for (let i = 0; i < particleCount; i++) {
                        const particle = new Particle('rain');
                        newParticles.push(particle);
                    }
                    
                    state.particles.push(...newParticles);
                    
                    const effect = {
                        type: 'rain',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        particles: newParticles,
                        timerId: null
                    };
                    
                    state.activeEffects.push(effect);
                    log(`üåßÔ∏è Rain effect started (${particleCount} particles, ${duration}ms)`);
                    
                    // Schedule auto-stop and store timer ID
                    effect.timerId = setTimeout(() => effects.rain.stop(effect), duration);
                },
                stop(effect) {
                    if (!effect) {
                        // Stop all rain effects
                        state.activeEffects.filter(e => e.type === 'rain').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                        });
                        state.particles = state.particles.filter(p => p.type !== 'rain');
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'rain');
                        log('üåßÔ∏è All rain effects stopped');
                    } else {
                        // Cancel timer to prevent memory leak
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        // Stop specific effect
                        effect.particles.forEach(p => p.destroy());
                        state.particles = state.particles.filter(p => p.active);
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        log('üåßÔ∏è Rain effect stopped');
                    }
                }
            },

            snow: {
                start(intensity = 0.5, duration = 10000) {
                    const particleCount = Math.floor(180 * intensity);
                    const newParticles = [];
                    
                    for (let i = 0; i < particleCount; i++) {
                        const particle = new Particle('snow');
                        newParticles.push(particle);
                    }
                    
                    state.particles.push(...newParticles);
                    
                    const effect = {
                        type: 'snow',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        particles: newParticles,
                        timerId: null
                    };
                    
                    state.activeEffects.push(effect);
                    log(`‚ùÑÔ∏è Snow effect started (${particleCount} particles, ${duration}ms)`);
                    
                    // Schedule auto-stop and store timer ID
                    effect.timerId = setTimeout(() => effects.snow.stop(effect), duration);
                },
                stop(effect) {
                    if (!effect) {
                        // Stop all snow effects
                        state.activeEffects.filter(e => e.type === 'snow').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                        });
                        state.particles = state.particles.filter(p => p.type !== 'snow');
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'snow');
                        log('‚ùÑÔ∏è All snow effects stopped');
                    } else {
                        // Cancel timer to prevent memory leak
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        effect.particles.forEach(p => p.destroy());
                        state.particles = state.particles.filter(p => p.active);
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        log('‚ùÑÔ∏è Snow effect stopped');
                    }
                }
            },

            storm: {
                start(intensity = 0.7, duration = 8000) {
                    const particleCount = Math.floor(350 * intensity);
                    const newParticles = [];
                    
                    for (let i = 0; i < particleCount; i++) {
                        const particle = new Particle('storm');
                        newParticles.push(particle);
                    }
                    
                    state.particles.push(...newParticles);
                    
                    const effect = {
                        type: 'storm',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        particles: newParticles,
                        nextShake: Date.now() + Math.random() * 1500,
                        timerId: null
                    };
                    
                    state.activeEffects.push(effect);
                    log(`‚õàÔ∏è Storm effect started (${particleCount} particles, ${duration}ms)`);
                    
                    // Darken screen slightly
                    safeGsap.to(canvas.style, {
                        filter: 'brightness(0.85)',
                        duration: 0.5,
                        ease: 'power2.inOut'
                    });
                    
                    // Schedule auto-stop and store timer ID
                    effect.timerId = setTimeout(() => effects.storm.stop(effect), duration);
                },
                stop(effect) {
                    if (!effect) {
                        // Stop all storm effects
                        state.activeEffects.filter(e => e.type === 'storm').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                        });
                        state.particles = state.particles.filter(p => p.type !== 'storm');
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'storm');
                    } else {
                        // Cancel timer to prevent memory leak
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        effect.particles.forEach(p => p.destroy());
                        state.particles = state.particles.filter(p => p.active);
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                    }
                    
                    // Restore brightness if no more storms
                    const hasStorm = state.activeEffects.some(e => e.type === 'storm');
                    if (!hasStorm) {
                        safeGsap.to(canvas.style, {
                            filter: 'brightness(1)',
                            duration: 0.8,
                            ease: 'power2.inOut'
                        });
                    }
                    
                    log('‚õàÔ∏è Storm effect stopped');
                }
            },

            fog: {
                start(intensity = 0.4, duration = 15000) {
                    const particleCount = Math.floor(40 * intensity);
                    const newParticles = [];
                    
                    for (let i = 0; i < particleCount; i++) {
                        const particle = new Particle('fog');
                        newParticles.push(particle);
                    }
                    
                    state.particles.push(...newParticles);
                    
                    const effect = {
                        type: 'fog',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        particles: newParticles,
                        timerId: null
                    };
                    
                    state.activeEffects.push(effect);
                    log(`üå´Ô∏è Fog effect started (${particleCount} particles, ${duration}ms)`);
                    
                    // Schedule auto-stop and store timer ID
                    effect.timerId = setTimeout(() => effects.fog.stop(effect), duration);
                },
                stop(effect) {
                    if (!effect) {
                        // Stop all fog effects
                        state.activeEffects.filter(e => e.type === 'fog').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                        });
                        state.particles = state.particles.filter(p => p.type !== 'fog');
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'fog');
                        log('üå´Ô∏è All fog effects stopped');
                    } else {
                        // Cancel timer to prevent memory leak
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        effect.particles.forEach(p => p.destroy());
                        state.particles = state.particles.filter(p => p.active);
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        log('üå´Ô∏è Fog effect stopped');
                    }
                }
            },

            thunder: {
                start(intensity = 0.8, duration = 5000) {
                    const effect = {
                        type: 'thunder',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        nextFlash: Date.now() + Math.random() * 800,
                        flashCount: 0,
                        timerId: null
                    };
                    
                    state.activeEffects.push(effect);
                    log(`‚ö° Thunder effect started (${duration}ms)`);
                    
                    // Schedule auto-stop and store timer ID
                    effect.timerId = setTimeout(() => effects.thunder.stop(effect), duration);
                },
                stop(effect) {
                    if (!effect) {
                        // Stop all thunder effects
                        state.activeEffects.filter(e => e.type === 'thunder').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                        });
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'thunder');
                        log('‚ö° All thunder effects stopped');
                    } else {
                        // Cancel timer to prevent memory leak
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        log('‚ö° Thunder effect stopped');
                    }
                }
            },

            sunbeam: {
                start(intensity = 0.6, duration = 12000) {
                    const beamCount = 6;
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    
                    const effect = {
                        type: 'sunbeam',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        beams: Array.from({ length: beamCount }, (_, i) => ({
                            x: (w / beamCount) * i + Math.random() * (w / beamCount),
                            angle: Math.random() * Math.PI / 6 - Math.PI / 12,
                            width: 60 + Math.random() * 120,
                            speed: 0.3 + Math.random() * 0.5,
                            opacity: 0
                        })),
                        timerId: null,
                        fadeTimerId: null
                    };
                    
                    // Fade in beams
                    effect.beams.forEach((beam, i) => {
                        safeGsap.to(beam, {
                            opacity: 1,
                            duration: 1,
                            delay: i * 0.1,
                            ease: 'power2.inOut'
                        });
                    });
                    
                    state.activeEffects.push(effect);
                    log(`‚òÄÔ∏è Sunbeam effect started (${beamCount} beams, ${duration}ms)`);
                    
                    // Fade out before stopping
                    effect.fadeTimerId = setTimeout(() => {
                        effect.beams.forEach((beam, i) => {
                            safeGsap.to(beam, {
                                opacity: 0,
                                duration: 1,
                                delay: i * 0.05,
                                ease: 'power2.inOut'
                            });
                        });
                    }, duration - 1200);
                    
                    // Schedule auto-stop and store timer ID
                    effect.timerId = setTimeout(() => effects.sunbeam.stop(effect), duration);
                },
                stop(effect) {
                    if (!effect) {
                        // Stop all sunbeam effects
                        state.activeEffects.filter(e => e.type === 'sunbeam').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                            if (e.fadeTimerId) clearTimeout(e.fadeTimerId);
                        });
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'sunbeam');
                        log('‚òÄÔ∏è All sunbeam effects stopped');
                    } else {
                        // Cancel timers to prevent memory leak
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        if (effect.fadeTimerId) {
                            clearTimeout(effect.fadeTimerId);
                            effect.fadeTimerId = null;
                        }
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        log('‚òÄÔ∏è Sunbeam effect stopped');
                    }
                }
            },

            glitchclouds: {
                start(intensity = 0.7, duration = 8000) {
                    const effect = {
                        type: 'glitchclouds',
                        intensity,
                        startTime: Date.now(),
                        duration,
                        glitchLines: [],
                        glitchInterval: null,
                        timerId: null
                    };
                    
                    state.activeEffects.push(effect);
                    log(`‚òÅÔ∏è Glitch Clouds effect started (${duration}ms)`);
                    
                    // Schedule auto-stop and store timer ID
                    effect.timerId = setTimeout(() => effects.glitchclouds.stop(effect), duration);
                },
                stop(effect) {
                    if (!effect) {
                        // Stop all glitch clouds effects
                        state.activeEffects.filter(e => e.type === 'glitchclouds').forEach(e => {
                            if (e.timerId) clearTimeout(e.timerId);
                        });
                        state.activeEffects = state.activeEffects.filter(e => e.type !== 'glitchclouds');
                        log('‚òÅÔ∏è All glitch clouds effects stopped');
                    } else {
                        // Cancel timer to prevent memory leak
                        if (effect.timerId) {
                            clearTimeout(effect.timerId);
                            effect.timerId = null;
                        }
                        state.activeEffects = state.activeEffects.filter(e => e !== effect);
                        log('‚òÅÔ∏è Glitch clouds effect stopped');
                    }
                }
            }
        };

        // Render loop with optimized performance
        function render(timestamp) {
            const deltaTime = Math.min(timestamp - state.lastFrameTime, 100); // Cap at 100ms to prevent huge jumps
            state.lastFrameTime = timestamp;

            // Clear canvas
            const w = window.innerWidth;
            const h = window.innerHeight;
            ctx.clearRect(0, 0, w, h);

            // Calculate FPS
            if (deltaTime > 0) {
                state.fps = Math.round(1000 / deltaTime);
                state.fpsHistory.push(state.fps);
                if (state.fpsHistory.length > 60) state.fpsHistory.shift();
            }

            // Update and draw particles (batch processing for better performance)
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const particle = state.particles[i];
                if (!particle.active) {
                    state.particles.splice(i, 1);
                    continue;
                }
                
                const effect = state.activeEffects.find(e => 
                    e.particles && e.particles.includes(particle)
                );
                const intensity = effect ? effect.intensity : 1.0;
                
                particle.update(deltaTime, intensity);
                particle.draw();
            }

            // Handle special effects
            for (let i = state.activeEffects.length - 1; i >= 0; i--) {
                const effect = state.activeEffects[i];
                const elapsed = Date.now() - effect.startTime;
                
                // Effects are auto-stopped by their own timers, but double-check
                if (elapsed > effect.duration + 1000) {
                    state.activeEffects.splice(i, 1);
                    continue;
                }

                // Thunder effect
                if (effect.type === 'thunder' && Date.now() >= effect.nextFlash) {
                    triggerLightning(effect.intensity);
                    effect.flashCount = (effect.flashCount || 0) + 1;
                    // Variable flash intervals for more realism
                    effect.nextFlash = Date.now() + 400 + Math.random() * 2500;
                }

                // Sunbeam effect
                if (effect.type === 'sunbeam' && effect.beams) {
                    drawSunbeams(effect);
                }

                // Glitch clouds effect
                if (effect.type === 'glitchclouds') {
                    drawGlitchClouds(effect);
                }

                // Storm camera shake
                if (effect.type === 'storm' && Date.now() >= effect.nextShake) {
                    shakeCamera(effect.intensity);
                    effect.nextShake = Date.now() + 800 + Math.random() * 2500;
                }
            }

            // Debug info
            if (config.debug) {
                updateDebugInfo();
            }

            // Continue animation
            state.animationId = requestAnimationFrame(render);
        }

        // Lightning flash effect with GSAP
        function triggerLightning(intensity) {
            const maxOpacity = 0.3 + intensity * 0.6;
            
            // Main flash
            safeGsap.to(lightningFlash, {
                opacity: maxOpacity,
                duration: 0.05,
                ease: 'power4.in',
                onComplete: () => {
                    safeGsap.to(lightningFlash, {
                        opacity: 0,
                        duration: 0.1,
                        ease: 'power2.out'
                    });
                }
            });

            // Sometimes double flash for realism
            if (Math.random() > 0.5) {
                safeGsap.to(lightningFlash, {
                    opacity: maxOpacity * 0.6,
                    duration: 0.04,
                    delay: 0.12,
                    ease: 'power4.in',
                    onComplete: () => {
                        safeGsap.to(lightningFlash, {
                            opacity: 0,
                            duration: 0.08,
                            ease: 'power2.out'
                        });
                    }
                });
            }
        }

        // Camera shake effect with GSAP
        function shakeCamera(intensity) {
            const shakeAmount = 6 * intensity;
            const shakeDuration = 0.5;
            
            safeGsap.to(canvas, {
                x: `+=${(Math.random() - 0.5) * shakeAmount}`,
                y: `+=${(Math.random() - 0.5) * shakeAmount}`,
                duration: 0.05,
                repeat: 8,
                yoyo: true,
                ease: 'power1.inOut',
                onComplete: () => {
                    safeGsap.set(canvas, { x: 0, y: 0 });
                }
            });
        }

        // Draw sunbeams with improved rendering
        function drawSunbeams(effect) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            effect.beams.forEach(beam => {
                // Move beams slowly
                beam.x += beam.speed;
                if (beam.x > w + 150) {
                    beam.x = -150;
                }

                // Create gradient beam
                const gradient = ctx.createLinearGradient(
                    beam.x, 0,
                    beam.x + beam.width, h
                );
                
                const baseOpacity = (beam.opacity || 1) * effect.intensity;
                gradient.addColorStop(0, `rgba(255, 235, 120, ${0.08 * baseOpacity})`);
                gradient.addColorStop(0.3, `rgba(255, 215, 100, ${0.15 * baseOpacity})`);
                gradient.addColorStop(0.7, `rgba(255, 200, 90, ${0.12 * baseOpacity})`);
                gradient.addColorStop(1, `rgba(255, 190, 70, ${0.04 * baseOpacity})`);

                ctx.fillStyle = gradient;
                
                // Draw angled beam
                ctx.beginPath();
                ctx.moveTo(beam.x, 0);
                ctx.lineTo(beam.x + beam.width, 0);
                ctx.lineTo(beam.x + beam.width + Math.tan(beam.angle) * h, h);
                ctx.lineTo(beam.x + Math.tan(beam.angle) * h, h);
                ctx.closePath();
                ctx.fill();
            });
            
            ctx.restore();
        }

        // Draw glitch clouds with improved effects
        function drawGlitchClouds(effect) {
            ctx.save();
            
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            // Generate random glitch lines
            if (Math.random() > 0.88) {
                const lineCount = 2 + Math.floor(Math.random() * 6);
                for (let i = 0; i < lineCount; i++) {
                    effect.glitchLines.push({
                        y: Math.random() * h,
                        height: 1 + Math.random() * 15,
                        color: ['#ff00ff', '#00ffff', '#ffff00', '#ff0000'][Math.floor(Math.random() * 4)],
                        offset: (Math.random() - 0.5) * 30,
                        life: 2 + Math.floor(Math.random() * 3),
                        alpha: 0.2 + Math.random() * 0.3
                    });
                }
            }

            // Draw and update glitch lines
            effect.glitchLines = effect.glitchLines.filter(line => {
                if (line.life <= 0) return false;
                
                ctx.fillStyle = line.color;
                ctx.globalAlpha = line.alpha * effect.intensity * (line.life / 5);
                ctx.fillRect(line.offset, line.y, w, line.height);
                
                line.life--;
                line.offset += (Math.random() - 0.5) * 5; // Jitter
                return true;
            });

            // Add digital noise overlay
            if (Math.random() > 0.75) {
                const noiseIntensity = effect.intensity * 0.05;
                ctx.globalAlpha = noiseIntensity;
                
                // Create noise pattern
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const size = 1 + Math.random() * 3;
                    const brightness = Math.random() * 255;
                    
                    ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                    ctx.fillRect(x, y, size, size);
                }
            }

            // RGB split effect occasionally
            if (Math.random() > 0.92) {
                const splitAmount = 3 * effect.intensity;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = w;
                tempCanvas.height = h;
                const tempCtx = tempCanvas.getContext('2d');
                
                // This would require storing the current frame, simplified for now
                ctx.globalAlpha = 0.3 * effect.intensity;
            }
            
            ctx.restore();
        }

        // Debug info display with enhanced metrics
        function updateDebugInfo() {
            debugInfo.classList.add('active');
            const avgFps = state.fpsHistory.length > 0 
                ? Math.round(state.fpsHistory.reduce((a, b) => a + b, 0) / state.fpsHistory.length)
                : 0;
            
            const connectionStatusText = state.connected ? 'Connected' : 'Disconnected';
            const connectionClass = state.connected ? 'connected' : 'disconnected';
            
            debugInfo.innerHTML = `
                <div class="status">
                    <div class="status-dot ${connectionClass}"></div>
                    <strong>Weather Control Debug</strong>
                </div>
                <div style="margin-top: 8px;">
                    <strong>Connection:</strong> ${connectionStatusText}<br>
                    <strong>FPS:</strong> ${state.fps} (avg: ${avgFps})<br>
                    <strong>Particles:</strong> ${state.particles.length} / ${config.maxParticles}<br>
                    <strong>Active Effects:</strong> ${state.activeEffects.length}<br>
                    ${state.activeEffects.map(e => 
                        `  ‚Üí ${e.type} (${Math.round(e.intensity * 100)}%)`
                    ).join('<br>')}
                    <br><strong>Events Received:</strong> ${state.totalEventsReceived}
                </div>
            `;
        }

        // Logging with timestamp
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] [Weather] ${message}`);
        }

        // Connection status display
        function updateConnectionStatus(status, message) {
            if (!config.showConnectionStatus && !config.debug) return;
            
            connectionStatus.className = `show ${status}`;
            connectionStatus.textContent = message;
            
            // Auto-hide success messages after 3 seconds
            if (status === 'connected') {
                setTimeout(() => {
                    connectionStatus.classList.remove('show');
                }, 3000);
            }
        }

        // WebSocket connection with robust error handling and reconnection
        function initSocket() {
            try {
                log('Initializing WebSocket connection...');
                
                state.socket = io({
                    transports: ['websocket', 'polling'],
                    reconnection: true,
                    reconnectionDelay: config.reconnectDelay,
                    reconnectionDelayMax: config.reconnectMaxDelay,
                    reconnectionAttempts: Infinity,
                    timeout: 20000,
                    forceNew: false
                });

                state.socket.on('connect', () => {
                    state.connected = true;
                    state.reconnectAttempts = 0;
                    log('‚úÖ Connected to server');
                    updateConnectionStatus('connected', '‚úì Connected');
                });

                state.socket.on('disconnect', (reason) => {
                    state.connected = false;
                    log(`‚ùå Disconnected from server: ${reason}`);
                    updateConnectionStatus('disconnected', '‚úó Disconnected');
                });

                state.socket.on('reconnect_attempt', (attemptNumber) => {
                    state.reconnectAttempts = attemptNumber;
                    log(`üîÑ Reconnection attempt ${attemptNumber}...`);
                    updateConnectionStatus('reconnecting', `‚ü≥ Reconnecting... (${attemptNumber})`);
                });

                state.socket.on('reconnect', (attemptNumber) => {
                    state.connected = true;
                    state.reconnectAttempts = 0;
                    log(`‚úÖ Reconnected after ${attemptNumber} attempts`);
                    updateConnectionStatus('connected', '‚úì Reconnected');
                });

                state.socket.on('reconnect_error', (error) => {
                    log(`‚ùå Reconnection error: ${error.message}`);
                });

                state.socket.on('reconnect_failed', () => {
                    log('‚ùå Reconnection failed - all attempts exhausted');
                    updateConnectionStatus('disconnected', '‚úó Connection failed');
                });

                state.socket.on('weather:trigger', (data) => {
                    state.totalEventsReceived++;
                    log(`üå¶Ô∏è Received weather event #${state.totalEventsReceived}: ${data.action}`);
                    handleWeatherEvent(data);
                });

                state.socket.on('weather:stop', (data) => {
                    log(`üõë Received weather stop event from ${data.username}`);
                    stopAllEffects();
                });

                state.socket.on('connect_error', (error) => {
                    log(`‚ùå Connection error: ${error.message}`);
                    updateConnectionStatus('disconnected', `‚úó Error: ${error.message}`);
                });

                state.socket.on('error', (error) => {
                    log(`‚ùå Socket error: ${error.message || error}`);
                });

            } catch (error) {
                log(`‚ùå Failed to initialize socket: ${error.message}`);
                updateConnectionStatus('disconnected', `‚úó Init failed: ${error.message}`);
            }
        }

        // Handle weather events from WebSocket
        function handleWeatherEvent(data) {
            try {
                const { action, intensity, duration, username } = data;
                
                // Validate event data
                if (!action) {
                    log('‚ö†Ô∏è Invalid event: missing action');
                    return;
                }
                
                if (!effects[action]) {
                    log(`‚ö†Ô∏è Unknown weather effect: ${action}`);
                    return;
                }
                
                // Trigger effect
                const validIntensity = Math.max(0, Math.min(1, parseFloat(intensity) || 0.5));
                const validDuration = Math.max(1000, Math.min(60000, parseInt(duration) || 10000));
                
                log(`üé¨ Triggering ${action} (intensity: ${validIntensity}, duration: ${validDuration}ms, user: ${username || 'unknown'})`);
                effects[action].start(validIntensity, validDuration);
                
            } catch (error) {
                log(`‚ùå Error handling weather event: ${error.message}`);
            }
        }

        // Stop all active weather effects
        function stopAllEffects() {
            try {
                log('üõë Stopping all weather effects...');
                let stoppedCount = 0;
                
                // Stop all active effects
                for (const effectName in effects) {
                    if (effects[effectName].active) {
                        effects[effectName].stop();
                        stoppedCount++;
                    }
                }
                
                // Clear all particles
                state.particles.length = 0;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                log(`‚úÖ Stopped ${stoppedCount} active effect(s)`);
                
            } catch (error) {
                log(`‚ùå Error stopping effects: ${error.message}`);
            }
        }

        // Initialize overlay
        function init() {
            log('üå¶Ô∏è Weather Control Overlay initializing...');
            log(`Version: Modernized v2.0`);
            log(`Debug mode: ${config.debug ? 'ENABLED' : 'disabled'}`);
            log(`Device Pixel Ratio: ${window.devicePixelRatio || 1}`);
            log(`Canvas size: ${canvas.width}x${canvas.height}`);
            
            // Start render loop
            state.lastFrameTime = performance.now();
            state.animationId = requestAnimationFrame(render);
            
            // Connect to WebSocket
            initSocket();
            
            // Show initial connection status
            if (config.debug || config.showConnectionStatus) {
                updateConnectionStatus('reconnecting', '‚ü≥ Connecting...');
            }
            
            log('‚úÖ Weather Control Overlay initialized successfully');
            log('Waiting for weather events via WebSocket...');
        }

        // Cleanup on unload
        function cleanup() {
            log('üßπ Cleaning up...');
            
            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }
            
            if (state.socket) {
                state.socket.disconnect();
                state.socket = null;
            }
            
            // Clear all effect timers to prevent memory leaks
            state.activeEffects.forEach(effect => {
                if (effect.timerId) {
                    clearTimeout(effect.timerId);
                    effect.timerId = null;
                }
                if (effect.fadeTimerId) {
                    clearTimeout(effect.fadeTimerId);
                    effect.fadeTimerId = null;
                }
            });
            
            // Clear all effects
            state.activeEffects = [];
            state.particles = [];
            
            log('‚úÖ Cleanup complete');
        }

        // Event listeners
        window.addEventListener('load', init);
        window.addEventListener('beforeunload', cleanup);
        
        // Handle visibility changes (for OBS optimization)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                log('üëÅÔ∏è Page hidden - pausing render loop');
                if (state.animationId) {
                    cancelAnimationFrame(state.animationId);
                    state.animationId = null;
                }
            } else {
                log('üëÅÔ∏è Page visible - resuming render loop');
                if (!state.animationId) {
                    state.lastFrameTime = performance.now();
                    state.animationId = requestAnimationFrame(render);
                }
            }
        });

        // Expose global API for testing (only in debug mode)
        if (config.debug) {
            window.weatherControl = {
                state,
                effects,
                triggerEffect: (action, intensity, duration) => {
                    handleWeatherEvent({ action, intensity, duration });
                },
                clearAll: () => {
                    state.activeEffects.forEach(e => {
                        if (effects[e.type]) {
                            effects[e.type].stop(e);
                        }
                    });
                },
                getStats: () => ({
                    fps: state.fps,
                    particles: state.particles.length,
                    effects: state.activeEffects.length,
                    connected: state.connected,
                    eventsReceived: state.totalEventsReceived
                })
            };
            log('üîß Debug API exposed: window.weatherControl');
        }
    </script>
</body>
</html>
